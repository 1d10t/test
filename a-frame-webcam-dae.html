<html>
<head>
<script src="https://aframe.io/releases/0.6.1/aframe.min.js"></script>
<script src="https://jeromeetienne.github.io/AR.js/aframe/build/aframe-ar.min.js"></script>
<script>THREEx.ArToolkitContext.baseURL = 'https://jeromeetienne.github.io/AR.js/three.js/'</script>
<script>
AFRAME.registerComponent('transparent-texture', {
	
	init: function () {
		this.applyToMesh();
		this.el.addEventListener('model-loaded', () => this.applyToMesh());
	},
	
	applyToMesh: function() {
		const mesh = this.el.getObject3D('mesh');
		if (mesh)
			mesh.traverse( function( child ) {
				if ( child.isMesh )
				{
					child.material.transparent = true;
					child.material.alphaTest = 0.5;
				}
			});
	}
	
});


function geo_watch(success, error) {
	
	if(!error)
		error = function(err) { console.warn(`ERROR(${err.code}): ${err.message}`); };
	
	if (!("geolocation" in navigator)){
		error({code: 0, message: 'Geolocation is not supported by your browser'});
		return;
	}
	
	return navigator.geolocation.watchPosition(success, error, {enableHighAccuracy: true, maximumAge: 0, timeout: 27000});
}

function meters(src, dest){
	var dlon = THREE.Math.degToRad(dest.longitude - src.longitude);
	var dlat = THREE.Math.degToRad(dest.latitude - src.latitude);
	var a = (Math.sin(dlat / 2) * Math.sin(dlat / 2)) + Math.cos(Math.radians(src.latitude)) * Math.cos(Math.radians(dest.latitude)) * (Math.sin(dlon / 2) * Math.sin(dlon / 2));
	var angle = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
	return angle * 6378160;
}


var zero_crd = null;
var geo_watch_id = null;

window.onload = function(){
	
	var camera = document.getElementById('camera');
	
	geo_watch_id = geo_watch(function(position){
		
		var crd = position.coords;
		
		crd_longitude.innerText = crd.longitude;
		crd_latitude.innerText = crd.latitude;
		
		if(crd.accuracy < 100){
			
			if(!zero_crd){
				zero_crd = crd;
				console.log('zero coords', zero_crd);
				
				zero_crd_longitude.innerText = zero_crd.longitude;
				zero_crd_latitude.innerText = zero_crd.latitude;
			}
			
			
			// lat = z
			// lon = x
			
			var p = camera.getAttribute('position');
			
			console.log('camera position', p);
			
			p.x = meters(zero_crd, {longitude: crd.longitude, latitude: zero_crd.latitude}) * (crd.longitude > zero_crd.longitude ? 1 : -1);
			p.z = meters(zero_crd, {longitude: zero_crd.longitude, latitude: crd.latitude}) * (crd.latitude > zero_crd.latitude ? 1 : -1);
			
			camera_p_x.innerText = p.x;
			camera_p_z.innerText = p.z;
			
			console.log('new camera position', p);
			
			camera.setAttribute('position', p);
			
		}else{
			
			
			
		}
		
	});
	
	/*
	move_interval = setInterval(function(){
		var p = camera.getAttribute('position');
		console.log('camera position', p);
		p.x += (Math.random()-0.5)*10;
		p.z += (Math.random()-0.5)*10;
		console.log('new camera position', p);
		camera.setAttribute('position', p);
	}, 3000);
	*/
}

</script>
</head>
<body style='margin: 0px; overflow: hidden;'>
	
	<div style='position: fixed; top: 10px; width:100%; text-align: center; z-index: 1;'>
		<div>
			coords: <span id="crd_longitude"></span>, <span id="crd_latitude"></span>
				(zero coords: <span id="zero_crd_longitude"></span>, <span id="zero_crd_latitude"></span>)
		</div>
		<div>
			camera coords: <span id="camera_p_x"></span>, <span id="camera_p_z"></span>
		</div>
	</div>
	
	<a-scene embedded artoolkit='sourceType: webcam;'>
		
		<a-camera id="camera" user-height="1.6"></a-camera>
		
		<a-assets>
			<a-asset-item id="fence_asset" src="fence11.dae"></a-asset-item>
		</a-assets>
		
		<a-entity id="fence" collada-model="#fence_asset" transparent-texture></a-entity>
		
	</a-scene>
</body>
</html>
