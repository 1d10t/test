<html>
<head>
<script src="https://aframe.io/releases/0.6.1/aframe.min.js"></script>
<script src="https://jeromeetienne.github.io/AR.js/aframe/build/aframe-ar.min.js"></script>
<script>THREEx.ArToolkitContext.baseURL = 'https://jeromeetienne.github.io/AR.js/three.js/'</script>
<script>
AFRAME.registerComponent('transparent-texture', {
	
	init: function () {
		this.applyToMesh();
		var $this = this;
		this.el.addEventListener('model-loaded', function(){ return $this.applyToMesh(); });
	},
	
	applyToMesh: function() {
		const mesh = this.el.getObject3D('mesh');
		if (mesh)
			mesh.traverse( function( child ) {
				if ( child.isMesh )
				{
					child.material.transparent = true;
					child.material.alphaTest = 0.5;
				}
			});
	}
	
});


AFRAME.registerComponent('gps-position', {
	
	watchId: null,
	zeroCrd: null,
	crd: null,
	
	schema: {
		accuracy: {
			type: 'int',
			default: 100
		},
		'zero-crd-latitude': {
			type: 'number',
			default: NaN
		},
		'zero-crd-longitude': {
			type: 'number',
			default: NaN
		}
	},
	
	init: function () {
		
		if(!isNaN(this.data['zero-crd-latitude']) && !isNaN(this.data['zero-crd-longitude'])){
			this.zeroCrd = {latitude: this.data['zero-crd-latitude'], longitude: this.data['zero-crd-longitude']};
		}
		
		this.watchId = this.watchGPS(function(position){
			this.crd = position.coords;
			this.updatePosition();
		}.bind(this));
		
	},
	
	watchGPS: function (success, error) {
		
		if(typeof(error) == 'undefined')
			error = function(err) { console.warn('ERROR('+err.code+'): '+err.message); };
		
		if (!("geolocation" in navigator)){
			error({code: 0, message: 'Geolocation is not supported by your browser'});
			return;
		}
		
		return navigator.geolocation.watchPosition(success, error, {enableHighAccuracy: true, maximumAge: 0, timeout: 27000});
	},
	
	updatePosition: function () {
		
		if(this.crd.accuracy > this.data.accuracy) return;
		
		if(!this.zeroCrd) this.zeroCrd = this.crd;
		
		var p = this.el.getAttribute('position');
		
		p.x = this.calcMeters(
			this.zeroCrd,
			{
				longitude: this.crd.longitude,
				latitude: this.zeroCrd.latitude
			}
		) * (
			this.crd.longitude > this.zeroCrd.longitude
				? -1 : 1
		);
		p.z = this.calcMeters(
			this.zeroCrd,
			{
				longitude: this.zeroCrd.longitude,
				latitude: this.crd.latitude
			}
		) * (
			this.crd.latitude > this.zeroCrd.latitude
				? -1 : 1
		);
		
		this.el.setAttribute('position', p);
		
	},
	
	calcMeters: function(src, dest) {
		var dlon = THREE.Math.degToRad(dest.longitude - src.longitude);
		var dlat = THREE.Math.degToRad(dest.latitude - src.latitude);
		
		var a = (Math.sin(dlat / 2) * Math.sin(dlat / 2)) + Math.cos(THREE.Math.degToRad(src.latitude)) * Math.cos(THREE.Math.degToRad(dest.latitude)) * (Math.sin(dlon / 2) * Math.sin(dlon / 2));
		var angle = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
		
		return angle * 6378160;
	}
	
	remove: function() {
		if(this.watchId) navigator.geolocation.clearWatch(this.watchId);
		this.watchId = null;
	}
	
});


function geo_watch(success, error) {
	
	if(typeof(error) == 'undefined')
		error = function(err) { console.warn('ERROR('+err.code+'): '+err.message); };
	
	if (!("geolocation" in navigator)){
		error({code: 0, message: 'Geolocation is not supported by your browser'});
		return;
	}
	
	return navigator.geolocation.watchPosition(success, error, {enableHighAccuracy: true, maximumAge: 0, timeout: 27000});
}

Math.radians = THREE.Math.degToRad;

function meters(src, dest){
	var dlon = Math.radians(dest.longitude - src.longitude);
	var dlat = Math.radians(dest.latitude - src.latitude);
	var a = (Math.sin(dlat / 2) * Math.sin(dlat / 2)) + Math.cos(Math.radians(src.latitude)) * Math.cos(Math.radians(dest.latitude)) * (Math.sin(dlon / 2) * Math.sin(dlon / 2));
	var angle = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
	return angle * 6378160;
}




var zero_crd = null;
var geo_watch_id = null;

function set_camera_by_crd(camera, crd, accuracy){
	
	console.log('new gps position', crd);
	
	crd_longitude.innerText = crd.longitude;
	crd_latitude.innerText = crd.latitude;
	
	if(crd.accuracy < accuracy){
		
		if(!zero_crd){
			zero_crd = crd;
			console.log('zero coords', zero_crd);
			
			zero_crd_longitude.innerText = zero_crd.longitude;
			zero_crd_latitude.innerText = zero_crd.latitude;
		}
		
		
		// lat = z
		// lon = x
		
		var p = camera.getAttribute('position');
		
		console.log('camera position', p);
		
		p.x = meters(zero_crd, {longitude: crd.longitude, latitude: zero_crd.latitude}) * (crd.longitude > zero_crd.longitude ? -1 : 1);
		p.z = meters(zero_crd, {longitude: zero_crd.longitude, latitude: crd.latitude}) * (crd.latitude > zero_crd.latitude ? -1 : 1);
		
		camera_p_x.innerText = p.x;
		camera_p_z.innerText = p.z;
		
		console.log('new camera position', p);
		
		camera.setAttribute('position', p);
		
	}else{
		
		
		
	}
	
}




function compassHeading(alpha, beta, gamma) {
	
	// Convert degrees to radians
	var alphaRad = alpha * (Math.PI / 180);
	var betaRad = beta * (Math.PI / 180);
	var gammaRad = gamma * (Math.PI / 180);
	
	// Calculate equation components
	var cA = Math.cos(alphaRad);
	var sA = Math.sin(alphaRad);
	var cB = Math.cos(betaRad);
	var sB = Math.sin(betaRad);
	var cG = Math.cos(gammaRad);
	var sG = Math.sin(gammaRad);
	
	// Calculate A, B, C rotation components
	var rA = - cA * sG - sA * sB * cG;
	var rB = - sA * sG + cA * sB * cG;
	var rC = - cB * cG;
	
	// Calculate compass heading
	var compassHeading = Math.atan(rA / rB);
	
	// Convert from half unit circle to whole unit circle
	if(rB < 0) {
		compassHeading += Math.PI;
	}else if(rA < 0) {
		compassHeading += 2 * Math.PI;
	}
	
	// Convert radians to degrees
	compassHeading *= 180 / Math.PI;
	
	return compassHeading;
}

set_camera_by_angle.last_timestamp = 0;

set_camera_by_angle.look_controls = null;

function set_camera_by_angle(camera, angle, time_limit){
	
	if(typeof(time_limit) == 'undefined') time_limit = 1000;
	
	var timestamp = Date.now();
	
	if((set_camera_by_angle.last_timestamp + time_limit) > timestamp){
		return;
	}
	
	set_camera_by_angle.last_timestamp = timestamp;
	
	console.log('new camera angle', angle);
	
	compass_heading.innerText = angle;
	
	var r = camera.getAttribute('rotation');
	
	/*
	
	console.log('camera rotation', r);
	
	r.y = angle;
	
	console.log('new camera rotation', r);
	
	camera.setAttribute('rotation', r);
	*/
	
	
	var look_controls = set_camera_by_angle.look_controls;
	
	if(!look_controls){
		for(var i=0; i<camera.sceneEl.behaviors.tick.length; i++){
			var x = camera.sceneEl.behaviors.tick[i];
			if(x.attrName == 'look-controls'){
				look_controls = set_camera_by_angle.look_controls = x;
				break;
			}
		}
		
	}
	
	if(!look_controls) return;
	
	look_controls
		.yawObject.rotation.y = THREE.Math.degToRad(angle - r.y);
		//.yawObject.rotation.y = THREE.Math.degToRad(angle);
	/**/
}

window.onload = function(){
	
	var camera = document.getElementById('camera');
	
	/* gps camera positioning 
	console.log('gps camera positioning');
	geo_watch_id = geo_watch(function(position){
		
		var crd = position.coords;
		
		set_camera_by_crd(camera, crd, 100);
		
	});*/
	/* /gps camera positioning */
	
	/* fake camera positioning 
	console.log('fake camera positioning');
	zero_crd = {longitude: 55.1409698, latitude: 37.4602963, accuracy: 10};
	var crd = JSON.parse(JSON.stringify(zero_crd));
	
	move_interval = setInterval(function(){
		
		crd.longitude += (Math.random()-0.5)/10000;
		crd.latitude += (Math.random()-0.5)/10000;
		
		set_camera_by_crd(camera, crd, 100);
		
	}, 3000);*/
	/* /fake camera positioning */
	
	/* magnet sensor camera positioning */
	
	function orientation_handler(evt) {
		
		var heading = null;
		
		if(typeof(evt.webkitCompassHeading) != 'undefined'){
			
			if(evt.webkitCompassAccuracy < 50){
				heading = evt.webkitCompassHeading;
			}else{
				compass_heading.innerText = 'webkitCompassAccuracy is evt.webkitCompassAccuracy';
			}
			
		}else if(evt.alpha !== null){
			if(evt.absolute === true || typeof(evt.absolute == 'undefined')) {
				heading = compassHeading(evt.alpha, evt.beta, evt.gamma);
			}else{
				compass_heading.innerText = 'evt.absolute === false';
			}
		}else{
			compass_heading.innerText = 'evt.alpha === null';
		}
		
		if(heading !== null)
			set_camera_by_angle(camera, heading, 1000);
		
	}
	
	if('ondeviceorientationabsolute' in window){
		window.addEventListener('deviceorientationabsolute', orientation_handler, false);
	}else if('ondeviceorientation' in window){
		window.addEventListener('deviceorientation', orientation_handler, false);
	}else{
		compass_heading.innerText = 'not supported';
	}
	
	window.addEventListener('compassneedscalibration', function(event) {
		alert('Your compass needs calibrating! Wave your device in a figure-eight motion');
		event.preventDefault();
	}, true);
	
	/* /magnet sensor camera positioning */
	
	camera.addEventListener('componentchanged', function (evt) {
		switch(evt.detail.name){
			case 'rotation':
				console.log('camera rotation changed', evt.detail.newData);
				camera_angle.innerText = evt.detail.newData.y;
				break;
			case 'position':
				console.log('camera position changed', evt.detail.newData);
				camera_p_x.innerText = evt.detail.newData.x;
				camera_p_y.innerText = evt.detail.newData.y;
				break;
		}
	});
	
}








</script>
</head>
<body style='margin: 0px; overflow: hidden;'>
	
	<div style="position: fixed; top: 10px; width:100%; text-align: center; z-index: 1; text-shadow: -1px 0 white, 0 1px white, 1px 0 white, 0 -1px white;">
		<div>
			coords: <span id="crd_longitude"></span>, <span id="crd_latitude"></span>
				(zero coords: <span id="zero_crd_longitude"></span>, <span id="zero_crd_latitude"></span>)
		</div>
		<div>
			camera coords: <span id="camera_p_x"></span>, <span id="camera_p_z"></span>
		</div>
		<div>
			compass heading: <span id="compass_heading"></span>,
			camera angle: <span id="camera_angle"></span>
		</div>
	</div>
	
	<a-scene embedded artoolkit='sourceType: webcam;'>
		
		<a-camera id="camera" user-height="1.6" gps-position></a-camera>
		
		<a-assets>
			<a-asset-item id="fence_asset" src="fence11.dae"></a-asset-item>
		</a-assets>
		
		<a-entity id="fence" collada-model="#fence_asset" transparent-texture></a-entity>
		
	</a-scene>
</body>
</html>
